# org.nextframework.compilation

## Overview

Runtime Java source code generation and compilation. Dynamically generate Java classes, compile them in memory, and load them at runtime without any disk I/O.

```java
SourceCodeBuilder builder = new SourceCodeBuilder();
builder.setPackage("com.example");
builder.setClassName("Person");
builder.addProperty("String", "name");

Class<?> personClass = builder.generateClass();  // Compiled in memory
Object person = personClass.getDeclaredConstructor().newInstance();
```

---

## Architecture

```
org.nextframework.compilation/
└── src/org/nextframework/compilation/
    ├── JavaSourceCompiler.java       # Compiles source code in memory
    ├── SourceCodeBuilder.java        # Fluent API for building Java classes
    ├── SourceCodeBlock.java          # Represents a code block (method body, etc.)
    ├── SourceCodeUtils.java          # Utility methods (capitalize, etc.)
    ├── MemoryJavaOutputFileManager.java  # In-memory file manager
    ├── MemoryJavaOutputFileObject.java   # In-memory compiled class
    └── AutoGenerated.java            # Marker interface for generated classes
```

---

## Key Classes

| Class | Purpose |
|-------|---------|
| `JavaSourceCompiler` | Compiles Java source code in memory and loads the class |
| `SourceCodeBuilder` | Fluent API for building complete Java class source code |
| `SourceCodeBlock` | Represents a block of code (method, constructor, etc.) |
| `AutoGenerated` | Marker interface to identify generated classes |

---

## Basic Example

### Generating a Simple Class

```java
import org.nextframework.compilation.SourceCodeBuilder;

// Create a new class builder
SourceCodeBuilder builder = new SourceCodeBuilder();
builder.setPackage("com.example.generated");
builder.setClassName("Person");

// Add properties (generates field + getter + setter)
builder.addProperty("String", "name");
builder.addProperty("Integer", "age");

// Get the generated source code
String sourceCode = builder.getSourceCode();
System.out.println(sourceCode);
```

### Generated Source Code

```java
package com.example.generated;

public class Person {

    String name;
    Integer age;

    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return this.age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

}
```

---

## Compile and Load at Runtime

```java
import org.nextframework.compilation.SourceCodeBuilder;

SourceCodeBuilder builder = new SourceCodeBuilder();
builder.setPackage("com.example.generated");
builder.setClassName("Person");
builder.addProperty("String", "name");
builder.addProperty("Integer", "age");

// Compile and load the class
Class<?> personClass = builder.generateClass();

// Create an instance
Object person = personClass.getDeclaredConstructor().newInstance();

// Use reflection to set properties
Method setName = personClass.getMethod("setName", String.class);
setName.invoke(person, "John");

Method getName = personClass.getMethod("getName");
System.out.println(getName.invoke(person)); // Output: John
```

---

## Advanced Usage

### Extending a Class

```java
SourceCodeBuilder builder = new SourceCodeBuilder();
builder.setSuperclass(BaseEntity.class);  // Sets package and generates class name
builder.addProperty("String", "title");

Class<?> entityClass = builder.generateClass();
```

### Implementing Interfaces

```java
SourceCodeBuilder builder = new SourceCodeBuilder();
builder.setPackage("com.example");
builder.setClassName("MyService");
builder.addImplements(Serializable.class);
builder.addImplements(Comparable.class);
```

### Adding Custom Methods

```java
SourceCodeBuilder builder = new SourceCodeBuilder();
builder.setPackage("com.example");
builder.setClassName("Calculator");

// Declare a method and get the block to add code
SourceCodeBlock method = builder.declareMethod("public int add(int a, int b)");
method.statement("return a + b");
```

### Adding Annotations

```java
SourceCodeBuilder builder = new SourceCodeBuilder();
builder.setPackage("com.example");
builder.setClassName("MyEntity");
builder.addAnnotation("@Entity");
builder.addImport("javax.persistence.Entity");
```

### Constructor

```java
SourceCodeBuilder builder = new SourceCodeBuilder();
builder.setPackage("com.example");
builder.setClassName("Person");
builder.addProperty("String", "name");

SourceCodeBlock constructor = builder.declareConstructor("String name");
constructor.statement("this.name = name");
```

---

## SourceCodeBlock API

| Method | Description |
|--------|-------------|
| `statement(String code)` | Adds a statement with automatic semicolon |
| `append(String code)` | Adds raw code |
| `call(String method, Object... params)` | Adds a method call |
| `addAnnotation(String ann)` | Adds an annotation to the block |
| `declareMethod(String declaration)` | Creates a nested method block |

### Example

```java
SourceCodeBlock method = builder.declareMethod("public String greet(String name)");
method.addAnnotation("@Override");
method.statement("String greeting = \"Hello, \" + name");
method.statement("return greeting");
```

---

## Direct Compilation

For cases where you already have source code as a string:

```java
import org.nextframework.compilation.JavaSourceCompiler;

String sourceCode = """
    package com.example;

    public class HelloWorld {
        public String sayHello() {
            return "Hello, World!";
        }
    }
    """;

ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
Class<?> clazz = JavaSourceCompiler.compileClass(
    classLoader,
    "com.example.HelloWorld",
    sourceCode.getBytes()
);

Object instance = clazz.getDeclaredConstructor().newInstance();
Method sayHello = clazz.getMethod("sayHello");
System.out.println(sayHello.invoke(instance)); // Output: Hello, World!
```

---

## How It Works

1. **Source Generation**: `SourceCodeBuilder` creates Java source code as a String
2. **In-Memory Compilation**: `JavaSourceCompiler` uses `javax.tools.JavaCompiler` to compile the source
3. **Memory Storage**: `MemoryJavaOutputFileManager` stores the compiled bytecode in memory (no disk I/O)
4. **Class Loading**: The bytecode is loaded into the JVM using reflection on `ClassLoader.defineClass()`

---

## Class Lifecycle and Memory Management

When generating classes dynamically, you may want to discard them later to free memory. Classes in Java can only be garbage collected when their ClassLoader is no longer referenced. By using a dedicated `URLClassLoader` for your generated classes, you can "drop" all those classes by simply discarding the ClassLoader reference:

```java
// Create a dedicated ClassLoader for generated classes
URLClassLoader disposableLoader = new URLClassLoader(new URL[0], parentClassLoader);

// Generate classes into this loader
Class<?> tempClass = builder.generateClass(disposableLoader);

// Use the class...
Object instance = tempClass.getDeclaredConstructor().newInstance();

// When done, discard all generated classes by releasing the loader
disposableLoader.close();
disposableLoader = null;
// Classes become eligible for garbage collection
```

This pattern is useful for:
- Long-running applications that generate many temporary classes
- Plugin systems where plugins can be loaded and unloaded
- Testing scenarios that need class isolation
- Avoiding `OutOfMemoryError: Metaspace` from excessive class generation

---

## Requirements

- **JDK** (not just JRE) - The `javax.tools.JavaCompiler` requires a JDK installation
- Classes are cached after compilation - compiling the same class twice returns the cached version

---

## Integration with Next Framework

When using with Next Framework annotations:

```java
import org.nextframework.compilation.SourceCodeBuilder;
import java.util.Date;

SourceCodeBuilder builder = new SourceCodeBuilder();
builder.setPackage("com.example.form");
builder.setClassName("PersonForm");

// Add property with display name and required validation
builder.addProperty(String.class, "name", "Full Name", true);
builder.addProperty(Date.class, "birthDate", "Date of Birth", false);

// Generates:
// @DisplayName("Full Name")
// @Required
// public String getName() { ... }
```
