package org.nextframework.report.generator.source;

import java.lang.reflect.Type;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.nextframework.bean.BeanDescriptor;
import org.nextframework.bean.BeanDescriptorFactory;
import org.nextframework.bean.PropertyDescriptor;
import org.nextframework.chart.Chart;
import org.nextframework.chart.ChartData;
import org.nextframework.chart.ChartDataBuilder;
import org.nextframework.chart.ChartDataTimeSeries;
import org.nextframework.chart.ChartType;
import org.nextframework.compilation.AutoGenerated;
import org.nextframework.compilation.SourceCodeBlock;
import org.nextframework.compilation.SourceCodeBuilder;
import org.nextframework.report.definition.builder.GroupSetup;
import org.nextframework.report.definition.elements.ReportConstants;
import org.nextframework.report.definition.elements.ReportTextField;
import org.nextframework.report.definition.elements.Subreport;
import org.nextframework.report.definition.elements.style.ReportAlignment;
import org.nextframework.report.generator.ReportElement;
import org.nextframework.report.generator.ReportGenerator;
import org.nextframework.report.generator.ReportGeneratorUtils;
import org.nextframework.report.generator.annotation.ReportField;
import org.nextframework.report.generator.chart.ChartElement;
import org.nextframework.report.generator.chart.ChartSerieElement;
import org.nextframework.report.generator.data.CalculatedFieldElement;
import org.nextframework.report.generator.data.FieldFormatter;
import org.nextframework.report.generator.layout.DynamicReportLayoutBuilder;
import org.nextframework.report.generator.layout.FieldDetailElement;
import org.nextframework.report.generator.layout.LayoutElement;
import org.nextframework.report.generator.layout.LayoutItem;
import org.nextframework.report.renderer.jasper.builder.JasperRenderParameters;
import org.nextframework.summary.Summary;
import org.nextframework.summary.SummaryUtils;
import org.nextframework.summary.annotations.CalculationType;
import org.nextframework.summary.compilation.SummaryResult;
import org.nextframework.summary.dynamic.DynamicSummary;
import org.nextframework.summary.dynamic.DynamicVariable;
import org.nextframework.types.Cpf;
import org.nextframework.util.Util;
import org.nextframework.view.chart.aggregate.ChartAverageAggregateFunction;
import org.nextframework.view.chart.aggregate.ChartAverageNotNullAggregateFunction;
import org.nextframework.view.chart.aggregate.ChartMaxAggregateFunction;
import org.nextframework.view.chart.aggregate.ChartMinAggregateFunction;
import org.nextframework.view.chart.aggregate.ChartSumAggregateFunction;
import org.springframework.beans.BeanUtils;
import org.springframework.util.StringUtils;

public class ReportBuilderSourceGenerator {

	private static final int MAXIMUM_COLUMN_WIDTH = 500;
	private ReportGenerator generator;
	private String className;

	public ReportBuilderSourceGenerator(ReportGenerator reportGenerator) {
		this.generator = reportGenerator;
	}

	public int getNumberOfColumns() {
		return generator.getReportElement().getLayout().getItems().size();
	}

	@SuppressWarnings("serial")
	Map<String, String> aggregateFunctions = new HashMap<String, String>() {

		{
			put("SUM", "new " + ChartSumAggregateFunction.class.getSimpleName() + "()");
			put("AVERAGE", "new " + ChartAverageAggregateFunction.class.getSimpleName() + "()");
			put("AVERAGENN", "new " + ChartAverageNotNullAggregateFunction.class.getSimpleName() + "()");
			put("MAX", "new " + ChartMaxAggregateFunction.class.getSimpleName() + "()");
			put("MIN", "new " + ChartMinAggregateFunction.class.getSimpleName() + "()");
		}

	};

	private int getSuggestedWidthForColumn(int i) {
		LayoutItem layoutItem = generator.getReportElement().getLayout().getItems().get(i);
		if (layoutItem instanceof FieldDetailElement) {
			FieldDetailElement fieldDetail = (FieldDetailElement) layoutItem;
			String fieldName = fieldDetail.getName();
			if (generator.getReportElement().getData().isCalculated(fieldName)) {
				return 50;
			}
			BeanDescriptor bd = BeanDescriptorFactory.forClass(getMainType());
			PropertyDescriptor propertyDescriptor = bd.getPropertyDescriptor(fieldName);
			ReportField reportField = propertyDescriptor.getAnnotation(ReportField.class);
			if (reportField != null && reportField.suggestedWidth() > 0) {
				return reportField.suggestedWidth();
			}
			Type type = propertyDescriptor.getType();
			if (type instanceof Class<?>) {
				Class<?> c = (Class<?>) type;
				//if(isDate(c)){
				//	if(fieldDetail.isDatePattern()){
				//		return (int)Math.floor(fieldDetail.getPattern().length() * 7.65);
				//	}
				//	return 70;
				//}
				if (isNumber(c)) {
					return 50;
				}
				if (Cpf.class.isAssignableFrom(c)) {
					return 68;
				}
			}
		}
		return -1;
	}

	private boolean isNumber(Class<?> c) {
		return Number.class.isAssignableFrom(c) || c.getSimpleName().contains("Money");
	}

	//private boolean isDate(Class<?> c) {
	//	return Calendar.class.isAssignableFrom(c) || Date.class.isAssignableFrom(c);
	//}

	public String getSource() {
		SourceCodeBuilder source = createSourceCodeBuilder();
		return source.toString();
	}

	public SourceCodeBuilder createSourceCodeBuilder() {

		SourceCodeBuilder source = new SourceCodeBuilder();

		source.setPackage(getMainType(), "report.builder");

		source.addImport(getMainType());
		source.addImport(GroupSetup.class);
		source.addImport(ReportTextField.class);
		source.addImport(ReportConstants.class);
		source.addImport(Subreport.class);
		source.addImport(SummaryResult.class);
		source.addImport(JasperRenderParameters.class);
		source.addImport(Util.class);

		source.setClassName(getClassName());

		source.setSuperclass(DynamicReportLayoutBuilder.class);

		source.addImplements(AutoGenerated.class);

		SourceCodeBlock columnConfigMethod = source.declareMethod("public int[] getColumnConfig()", true);
		columnConfigMethod.append("return new int[]{");
		int numberOfColumns = getNumberOfColumns();
		int[] widths = new int[numberOfColumns];
		int sum = 0;
		int fixedColumnCount = 0;
		for (int i = 0; i < numberOfColumns; i++) {
			widths[i] = getSuggestedWidthForColumn(i);
			if (widths[i] > 0) {
				sum += widths[i];
				fixedColumnCount++;
			}
		}

		if (sum > MAXIMUM_COLUMN_WIDTH) {
			int diff = sum - MAXIMUM_COLUMN_WIDTH;
			int reduce = diff / fixedColumnCount + 1;
			for (int i = 0; i < widths.length; i++) {
				if (widths[i] > 0) {
					widths[i] -= reduce;
				}
			}
		}

		for (int i = 0; i < numberOfColumns; i++) {
			int width = widths[i];
			String widthString = width == -1 ? "ReportConstants.AUTO_WIDTH" : "" + width;
			columnConfigMethod.append("    " + widthString + (i + 1 < numberOfColumns ? "," : ""));
		}
		columnConfigMethod.append("};");

		source.declareMethod("public String getTitle()", true)
				.append("return \"" + generator.getReportElement().getReportTitle() + "\";");

		SourceCodeBlock layoutMethod = source.declareMethod("protected void layoutReportFields()", true);

		if (generator.getReportElement().getCharts() != null && generator.getReportElement().getCharts().getItems().size() > 0) {
			List<ChartElement> charts = generator.getReportElement().getCharts().getItems();
			source.addImport(Chart.class);
			source.addImport(ChartData.class);
			source.addImport(ChartType.class);
			source.addImport(ChartDataBuilder.class);
			source.addImport(ChartDataTimeSeries.class);
			source.addImport(Summary.class);
			source.addImport(Calendar.class);
			source.addImport(SummaryResult.class);
			source.addImport(DynamicSummary.class);
			source.addImport(DynamicVariable.class);
			source.addImport(CalculationType.class);
			source.addImport("org.nextframework.chart.ChartStyle.LegendPosition");
			source.addImport("org.nextframework.view.chart.aggregate.*");
			SourceCodeBlock chatsMethod = source.declareMethod("protected void createCharts()", true);
			for (int i = 0; i < charts.size(); i++) {
				ChartElement chart = charts.get(i);
				generateChart(source, chatsMethod, i, chart, generator.getReportElement());
			}
		}

		LayoutElement layout = generator.getReportElement().getLayout();

		List<LayoutItem> items = layout.getItems();
		for (LayoutItem layoutItem : items) {
			if (layoutItem instanceof FieldDetailElement) {

				FieldDetailElement fieldDetail = (FieldDetailElement) layoutItem;
				boolean calculated = generator.getReportElement().getData().isCalculated(fieldDetail.getName());

				String fieldName = StringUtils.uncapitalize(fieldDetail.getName());
				if (fieldDetail.isAggregateField() || fieldDetail.isCustomPattern()) {
					fieldName = SummaryUtils.convertCompositeGroupToMethodFormat(fieldName, true);
				}

				if (calculated || fieldDetail.isCustomPattern()) {
					fieldName = "summary." + fieldName;
				}

				String functionName = "fieldDetail";
				if (fieldDetail.isAggregateField()) {
					functionName = "fieldSummary";
				}

				if (fieldDetail.isCustomPattern()) {
					ReportAlignment alignment = ((FieldFormatter) BeanUtils.instantiate(fieldDetail.getCustomPatternClass())).getAlignment();
					if (fieldDetail.getLabel() != null) {
						layoutMethod.call(functionName, fieldName + "Formatted", fieldDetail.getLabel(), alignment);
					} else {
						layoutMethod.call(functionName, fieldName + "Formatted", alignment);
					}
				} else if (fieldDetail.getPattern() != null) {
					layoutMethod.call(functionName, fieldName, fieldDetail.getLabel(), fieldDetail.getPattern());
				} else if (fieldDetail.getLabel() != null) {
					layoutMethod.call(functionName, fieldName, fieldDetail.getLabel());
				} else {
					layoutMethod.call(functionName, fieldName);
				}

			}
		}

		source.declareMethod("protected Class<?> getRowClass()", true).statement("return " + getMainType().getSimpleName() + ".class");

		return source;
	}

	private Class<?> getMainType() {
		return generator.getReportElement().getData().getMainType();
	}

	private void generateChart(SourceCodeBuilder source, SourceCodeBlock layoutMethod, int i, ChartElement chart, ReportElement reportElement) {

		Class<?> mainType = getMainType();
		BeanDescriptor mainBD = BeanDescriptorFactory.forClass((Class<?>) mainType);
		Type groupType = mainBD.getPropertyDescriptor(chart.getGroupProperty()).getType();

		layoutMethod.append("Chart chart" + i + " = getChart" + i + "();");
		layoutMethod.append("column(0, getColumnQuantity()).detail(chart" + i + ");");
		layoutMethod.append("getDefinition().getSectionDetail().breakLine();");
		layoutMethod.append("column(0, getColumnQuantity()).detail(getChartTable(chart" + i + "));");
		layoutMethod.append("getDefinition().getSectionDetail().breakLine();");

		SourceCodeBlock chartMethod = source.declareMethod("private Chart getChart" + i + "()");

		String groupProperty = chart.getGroupProperty();

		//do not use description property for groups anymore
		//groupProperty = checkDescriptor(groupProperty);

		String classSimpleName = getMainType().getSimpleName();
		chartMethod.append("Class<Summary<" + classSimpleName + ">> summaryClass = DynamicSummary.getInstance(" + classSimpleName + ".class)");
		chartMethod.append("\t.addGroup(\"" + groupProperty + "\")");
		if (org.springframework.util.StringUtils.hasText(chart.getSeriesProperty())) {
			chartMethod.append("\t.addGroup(\"" + chart.getSeriesProperty() + "\")");
		}
		if ("true".equals(chart.getPropertiesAsSeries())) {
			BeanDescriptor bd = BeanDescriptorFactory.forClass(getMainType());
			List<ChartSerieElement> series = chart.getSeries();
			for (ChartSerieElement chartSerieElement : series) {
				String property = chartSerieElement.getProperty();
				if (!reportElement.getData().isCalculated(property)) {
					String displayName = bd.getPropertyDescriptor(property).getDisplayName();
					if (StringUtils.hasText(chartSerieElement.getLabel())) {
						displayName = chartSerieElement.getLabel();
					}
					chartMethod.append("\t.addVariable(\"" + property + "\", \"" + displayName + "\", CalculationType." + CalculationType.valueOf(chartSerieElement.getAggregateFunction()) + ")");
				}
			}
			for (ChartSerieElement chartSerieElement : series) {
				String property = chartSerieElement.getProperty();
				if (reportElement.getData().isCalculated(property)) {
					CalculatedFieldElement calculatedField = reportElement.getData().getCalculatedFieldWithName(property);
					String displayName = calculatedField.getDisplayName();
					if (StringUtils.hasText(chartSerieElement.getLabel())) {
						displayName = chartSerieElement.getLabel();
					}
					boolean formatAsNumber = CalculatedFieldElement.FORMAT_AS_NUMBER.equals(calculatedField.getFormatAs());
					String exp = ReportGeneratorUtils.reorganizeExpression(reportElement, getMainType(), calculatedField.getExpression(), calculatedField.getProcessors());
					if (!formatAsNumber) {
						String formatTimeDetail = calculatedField.getFormatTimeDetail();
						String timeDiv = ReportGenerator.convertToTimeFormula(formatTimeDetail);
						exp = "(" + exp + ") " + timeDiv;
					}
					chartMethod.append("\t.addVariable(new DynamicVariable(\"" + property + "\", \"" + displayName + "\", CalculationType." + CalculationType.valueOf(chartSerieElement.getAggregateFunction()) + ", " +
							"\"(double)(" + exp + ")\", Double.class))");
				}
			}
		} else {
			if (chart.getValueProperty().equals("count")) {
				chartMethod.append("\t.addCount()");
			} else {
				String property = chart.getValueProperty();
				if (reportElement.getData().isCalculated(property)) {
					CalculatedFieldElement calculatedField = reportElement.getData().getCalculatedFieldWithName(property);
					String displayName = calculatedField.getDisplayName();
					boolean formatAsNumber = CalculatedFieldElement.FORMAT_AS_NUMBER.equals(calculatedField.getFormatAs());
					String exp = ReportGeneratorUtils.reorganizeExpression(reportElement, getMainType(), calculatedField.getExpression(), calculatedField.getProcessors());
					if (!formatAsNumber) {
						String formatTimeDetail = calculatedField.getFormatTimeDetail();
						String timeDiv = ReportGenerator.convertToTimeFormula(formatTimeDetail);
						exp = "(" + exp + ") " + timeDiv;
					}
					chartMethod.append("\t.addVariable(new DynamicVariable(\"" + property + "\", \"" + displayName + "\", CalculationType." + CalculationType.valueOf(chart.getValueAggregate()) + ", " +
							"\"(double)(" + exp + ")\", Double.class))");
				} else {
					chartMethod.append("\t.addVariable(\"" + property + "\", CalculationType." + CalculationType.valueOf(chart.getValueAggregate()) + ")");
				}
			}
		}
		chartMethod.append("\t.getSummaryClass();");

		chartMethod.append("SummaryResult<" + classSimpleName + ", Summary<" + classSimpleName + ">> chartData = recalculateData(summaryClass).getSumariesForGroup(\""
				+ (org.springframework.util.StringUtils.hasText(chart.getSeriesProperty()) ? chart.getSeriesProperty() : chart.getGroupProperty())
				+ "\");");

		String groupPropertyForValue = org.springframework.util.StringUtils.hasText(chart.getSeriesProperty()) ? chart.getSeriesProperty() : chart.getGroupProperty();
		String groupPropertyForValueCap = SummaryUtils.convertCompositeGroupToMethodFormat(org.springframework.util.StringUtils.capitalize(groupPropertyForValue));
		if ("true".equals(chart.getPropertiesAsSeries())) {
			//ChartDataBuilder.buildPropertiesAsSeries(objects, groupPropertyForValue, `)
			chartMethod.append("ChartData sData = ChartDataBuilder.buildPropertiesAsSeries(chartData.getItems(), " +
					"\"summary." + SummaryUtils.convertCompositeGroupToMethodFormat(chart.getGroupProperty()) + "\" "  //group);
			);
			List<ChartSerieElement> series = chart.getSeries();
			for (ChartSerieElement chartSerieElement : series) {
				String property = StringUtils.uncapitalize(chartSerieElement.getProperty());
				property = SummaryUtils.convertCompositeGroupToMethodFormat(property);
				chartMethod.append(", \"summary." + property + groupPropertyForValueCap + "\"");
			}
			chartMethod.append(");");
		} else {
			String aggregateFunction = getAggregateFunctionObjectCreator(chart.getValueAggregate());
			String property = chart.getValueProperty();
			property = SummaryUtils.convertCompositeGroupToMethodFormat(property);
			chartMethod.append("ChartData sData = ChartDataBuilder.build(chartData.getItems(), " +
					"\"summary." + SummaryUtils.convertCompositeGroupToMethodFormat(chart.getGroupProperty()) + "\", " + //group
					(org.springframework.util.StringUtils.hasText(chart.getSeriesProperty()) ? "\"summary." + SummaryUtils.convertCompositeGroupToMethodFormat(chart.getSeriesProperty()) + "\", " : "null, ") + //series
					"\"summary." + property + groupPropertyForValueCap + "\"," + //value
					aggregateFunction + ");"); //aggregate
		}

		if (StringUtils.hasText(chart.getGroupTitle())) {
			String groupTitle = safeString(chart.getGroupTitle());
			chartMethod.append("sData.setGroupTitle(\"" + groupTitle + "\");");
		}
		if (StringUtils.hasText(chart.getSeriesTitle())) {
			String seriesTitle = safeString(chart.getSeriesTitle());
			chartMethod.append("sData.setSeriesTitle(\"" + seriesTitle + "\");");
		}

		chartMethod.append("Chart chart = new Chart(ChartType." + chart.getType().toUpperCase() + ");");

		if (groupType instanceof Class<?>) {
			if (Calendar.class.isAssignableFrom((Class<?>) groupType) ||
					Date.class.isAssignableFrom((Class<?>) groupType)) {
				chartMethod.append("ChartDataTimeSeries tsData = new ChartDataTimeSeries(sData);");
				if ("true".equals(chart.getPropertiesAsSeries())) {
					List<ChartSerieElement> series = chart.getSeries();
					StringBuilder aggregatesArrayBuffer = new StringBuilder();
					aggregatesArrayBuffer.append("new ChartAggregateFunction[]{");
					for (ChartSerieElement chartSerieElement : series) {
						String aggregateFunction = getAggregateFunctionObjectCreator(chartSerieElement.getAggregateFunction());
						aggregatesArrayBuffer.append(aggregateFunction);
						aggregatesArrayBuffer.append(", ");
					}
					aggregatesArrayBuffer.setLength(aggregatesArrayBuffer.length() - 2);
					aggregatesArrayBuffer.append("}");
					chartMethod.append("tsData.groupBy(" + chart.getGroupLevel() + ", " + aggregatesArrayBuffer + ");"); //TODO consider aggregation function
				} else {
					String aggregateFunction = getAggregateFunctionObjectCreator(chart.getValueAggregate());
					chartMethod.append("tsData.groupBy(" + chart.getGroupLevel() + ", " + aggregateFunction + ");"); //TODO consider aggregation function
				}
				chartMethod.append("sData = tsData;");
				chartMethod.append("chart.setGroupPattern(\"" + getPatternForGroupLevel(chart.getGroupLevel()) + "\");");
			}
		}

		if (org.springframework.util.StringUtils.hasText(chart.getSeriesProperty())) {
			chartMethod.append("//" + chart.getSeriesLimitType());
			if (ChartElement.SHOW_ALL.equals(chart.getSeriesLimitType())) {
			} else if (ChartElement.LIMIT.equals(chart.getSeriesLimitType())) {
				chartMethod.append("sData.limit(5);");
			} else if (ChartElement.GROUP.equals(chart.getSeriesLimitType())) {
				chartMethod.append("sData.regroup(5);");
			}
		}

		if (chart.isIgnoreEmptySeriesAndGroups()) {
			chartMethod.append("sData.removeEmptySeries();");
			chartMethod.append("sData.removeEmptyGroups();");
		}

		chartMethod.append("chart.setData(sData);");
		chartMethod.append("chart.setTitle(\"" + (chart.getTitle().replace('"', ' ')) + "\");");
		chartMethod.append("onNewChart(chart);");

		chartMethod.append("return chart;");

	}

	private String safeString(String groupTitle) {
		return groupTitle.replace('\\', ' ').replace('\"', ' ');
	}

	public String getAggregateFunctionObjectCreator(String valueAggregate) {
		if (valueAggregate == null) {
			valueAggregate = "SUM";//default
		}
		String aggregateFunction = aggregateFunctions.get(valueAggregate);
		if (aggregateFunction == null) {
			throw new IllegalArgumentException("Cannot aggregate chart by function " + valueAggregate + ". No aggregator for this type available.");
		}
		return aggregateFunction;
	}

	/*
	private String checkDescriptor(String propertyToCheck) {
		BeanDescriptor bd = BeanDescriptorFactory.forClass(getMainType());
		PropertyDescriptor propertyDescriptor = bd.getPropertyDescriptor(propertyToCheck);
		if (propertyDescriptor.getType() instanceof Class<?>) {
			BeanDescriptor bdp = BeanDescriptorFactory.forClass((Class<?>) propertyDescriptor.getType());
			if (((Class<?>) propertyDescriptor.getType()).isAnnotationPresent(Entity.class)) {
				String property = "class";
				if (bdp.getDescriptionPropertyName() != null) {
					property = bdp.getDescriptionPropertyName();
				} else if (bdp.getIdPropertyName() != null) {
					property = bdp.getIdPropertyName();
				}
				propertyToCheck = propertyToCheck + "." + property;
			}
		}
		return propertyToCheck;
	}
	*/

	private String getPatternForGroupLevel(String groupLevel) {
		switch (Integer.parseInt(groupLevel)) {
			case Calendar.YEAR:
				return "yyyy";
			case Calendar.MONTH:
				return "MM/yyyy";
			case Calendar.DATE:
				return "dd/MM/yyyy";
			case Calendar.HOUR_OF_DAY:
				return "dd/MM/yyyy HH";
			case Calendar.MINUTE:
				return "dd/MM/yyyy HH:mm";
		}
		return "dd/MM/yyyy HH:mm:ss";
	}

	public String getClassName() {
		if (className == null) {
			String name = generator.getReportElement().getName();
			char[] charArray = name.toCharArray();
			for (int i = 0; i < charArray.length; i++) {
				char c = charArray[i];
				if (i == 0 && !Character.isLetter(c)) {
					charArray[i] = '_';
				}
				if (!Character.isJavaIdentifierPart(c)) {
					charArray[i] = '_';
				}
			}
			className = org.springframework.util.StringUtils.capitalize(new String(charArray)) + "_ReportBuilder";
		}
		return className;
	}

	public void setClassName(String className) {
		this.className = className;
	}

	public String getQualifiedClassName() {
		Class<?> type = getMainType();
		return type.getName().substring(0, type.getName().lastIndexOf(type.getSimpleName())) + "report.builder." + getClassName();
	}

}
